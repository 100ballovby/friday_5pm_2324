class Bee:  # определение класса
    # поля (атрибут, параметр) и методы класса
    def __init__(self, n, r):  # конструктор класса
        """Конструктор наполняет экземпляр класса
        необходимыми параметрами, а также может выполнять
        действия, которые необходимо выполнить при создании
        нового экземпляра класса (последнее редко делается)"""
        self.name = n  # значение поля name будет задаваться из параметра, который передадут в конструкторе
        self.__role = r  # параметр role инкапсулирован (защищен)
        self.__age = 0  # параметр инкапсулирован, потому что возраст просто так менять нельзя

    def bzz(self):  # пользовательский метод (поведение класса)
        print(f'Bee {self.name}: bzzz')

    # напишем метод-геттер, который позволит показать роль пчелы
    def get_role(self):
        return self.__role  # внутри класса обращаться к инкапсулированным параметрам можно, вне класса НЕТ

    def get_age(self):
        return self.__age

    # напишем метод-сеттер, который позволит изменять возраст пчелы
    def set_age(self, age):
        """Метод-сеттер является интерфейсом для класса,
        то есть это возможность для пользователя менять параметры класса,
        но в рамках того, что вы сами позволите менять"""
        if age > self.__age and 0 < age < 100:  # если новый возраст больше старого и он в промежутке от 0 до 100
            self.__age = age  # поменять возраст пчелы

    # второй вариант метода-сеттера
    def birthday(self):
        self.__age += 1

    def __repr__(self):  # здесь обычно прописывается, что будет выводиться в случае вызова экземпляра
        return f'I am bee {self.name}'


b1 = Bee('Maya', 'security')  # экземпляру класса присваиваются необходимые параметры через конструктор
b2 = Bee('Kapa', 'queen')

b1.bzz()
b2.bzz()
b2.__role = 'bomzh'  # операция не может быть выполнена, потому что данные инкапсулированы
print(f'The role of {b2.name} is {b2.get_role()}')

print(f'{b1.name} is {b1.get_age()} y.o.')
b1.set_age(150)  # не сработает, потому что возраст не может быть больше 100 лет
b1.set_age(30)  # сработает, потому что условие в методе выполнится
b1.birthday()  # у пчелы был день рождения, прибавим ей год
print(f'{b1.name} is {b1.get_age()} y.o.')